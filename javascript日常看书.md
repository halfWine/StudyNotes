# 导出和导入

https://zh.javascript.info/import-export

注意点：
* 有很多要导入的内容，我们可以使用 import * as <obj> 将所有内容导入为一个对象。

```
// 📁 main.js
import * as say from './say.js';

say.sayHi('John');
say.sayBye('John');
```

乍一看，“通通导入”看起来很酷，写起来也很短，但是我们通常为什么要明确列出我们需要导入的内容？

* 现代的构建工具（webpack 和其他工具）将模块打包到一起并对其进行优化，以加快加载速度并删除未使用的代码。
* 明确列出要导入的内容会使得名称较短：sayHi() 而不是 say.sayHi()。
* 导入的显式列表可以更好地概述代码结构：使用的内容和位置。它使得代码支持重构，并且重构起来更容易。

# 为什么React.createElement 简称 h 函数

React.createElement函数的简称"h"来自于"hyperscript"的缩写。Hyperscript是一种创建虚拟DOM元素的语法，它最初在JavaScript库"virtual-dom"中得到广泛应用。由于React在设计上受到了virtual-dom的启发，因此React也采用了类似的语法。

在hyperscript中，使用一个函数来表示HTML标签，并传递相应的参数和子节点来创建元素。这个函数通常被命名为"h"或其他短小的名称，以简化代码书写和提高可读性。

React的createElement函数实际上就是对hyperscript的实现，它接受一个字符串参数作为标签名，以及一个可选的配置对象和子节点参数。为了保持与hyperscript的一致性，并且减少代码冗余，React选择将createElement函数简称为"h"函数。

通过使用"h"函数，开发者可以更加简洁地创建React元素，而不必每次都写出完整的createElement函数名称，从而提高开发效率。

# vue使用模板语法创建dom，react使用jsx创建dom，它们的区别是

Vue的模板语法和React的模板语法有一些区别。

1. 插值方式不同：在Vue中，可以使用双花括号{{}}进行数据插值，例如 `{{ message }}`。而在React中，使用花括号{}进行表达式插入，例如 `{message}`。

2. 条件渲染方式不同：在Vue中，可以使用v-if和v-else指令来进行条件渲染，例如 `<p v-if="showParagraph">This is a Vue template.</p>`。而在React中，可以使用JSX中的条件语句（如if语句或三元表达式）来实现条件渲染。

3. 列表渲染方式不同：在Vue中，可以使用v-for指令来进行列表渲染，例如 `<li v-for="item in list" :key="item.id">{{ item.name }}</li>`。而在React中，通常使用JavaScript的map函数来遍历数组并生成对应的元素列表。

4. 事件处理方式略有不同：在Vue中，可以使用v-on指令来绑定事件处理程序，例如 `@click="handleClick"`。而在React中，直接将事件处理函数作为属性传递给相应的元素，例如 `onClick={handleClick}`。

```
需要注意的是，React更加注重组件化和构建可复用UI组件，因此它更倾向于使用JavaScript编写组件逻辑，而将模板部分集成在JSX中。而Vue则更加注重模板的编写和使用，提供了更多直接在模板中操作数据和DOM的能力。
```

虽然两者的模板语法有一些差异，但它们都旨在让开发者能够以更直观、可读性更高的方式来描述UI组件的结构和行为。

# 他们都是怎么转化为js代码的

Vue的模板语法和React的JSX在底层都会被转化为JavaScript代码，以便最终在浏览器中执行。

对于Vue的模板语法，Vue使用了编译器来将模板转换为虚拟DOM渲染函数。这个过程包括以下步骤：

1. 解析模板：Vue的编译器会解析模板，将其分解为抽象语法树（AST），以便更好地理解模板的结构和指令。

2. 优化处理：编译器会对AST进行优化处理，包括静态节点提升、标记静态根节点等操作，以减少运行时的性能开销。

3. 生成代码：根据优化后的AST，编译器会生成可执行的JavaScript代码，其中包括创建虚拟节点的函数调用、指令处理逻辑等。

4. 执行代码：最终生成的JavaScript代码会被用于Vue实例的渲染过程，通过执行这些代码来生成并更新真实的DOM元素。

对于React的JSX，它本身就是一种JavaScript扩展语法，可以直接在代码中嵌入类似HTML的标签结构。然而，浏览器无法直接理解JSX，因此需要通过工具进行转换。常见的转换步骤如下：

1. Babel转换：通常我们使用Babel等工具来将JSX转换为普通的JavaScript代码。Babel使用对应的插件（如@babel/preset-react）来解析和转换JSX语法，将其转化为React.createElement函数调用的形式。

2. 创建React元素：转换后的代码会使用React.createElement函数创建虚拟DOM元素，其中包括标签名、属性和子节点等信息。

3. 渲染和更新：通过执行这些生成的JavaScript代码，React会根据虚拟DOM的变化来进行渲染和更新实际的DOM元素。

总结而言，Vue的模板语法会经过编译器的处理，最终转化为可执行的JavaScript代码。而React的JSX则需要通过工具将其转换为React.createElement函数调用的形式，并由React负责生成和更新虚拟DOM。这两种方式都旨在让开发者以一种更直观、易于理解的方式编写UI组件，并最终转化为可执行的JavaScript代码。

# vue的模板语法和react的jsx语法对比优势和劣势分别是什么？那个更好

Vue的模板语法和React的JSX语法各有优势和劣势，具体取决于项目需求、个人喜好以及团队的技术栈。

Vue的模板语法优势：
- 可读性强：Vue的模板语法类似于HTML，更接近直观的描述UI组件结构，易于理解和维护。
- 快速上手：对于前端开发者来说，如果熟悉HTML和Vue的指令，那么学习和使用Vue的模板语法会比较容易。
- HTML友好：Vue的模板语法内嵌于HTML中，使得前端设计师等非开发人员能够更轻松地参与到项目中。

Vue的模板语法劣势：
- 限制较多：模板语法相对于JavaScript代码来说，功能和灵活性有一些限制，无法直接使用JavaScript语法或表达式。
- 开发规模限制：在大型项目中，模板语法可能不够灵活，难以处理复杂的逻辑和代码重用。

React的JSX语法优势：
- JavaScript的完全控制权：使用JSX可以直接在JavaScript中编写组件逻辑和条件判断，提供了完全的编程能力和灵活性。
- 更具封装性：JSX鼓励组件化开发，组件可以更好地封装和复用，促进代码的模块化和可维护性。
- 更加灵活：由于JSX是JavaScript的扩展语法，开发者可以结合任何JavaScript库和工具来构建应用，享受更广泛的生态系统。

React的JSX语法劣势：
- 上手难度较高：相对于HTML类似的模板语法，JSX需要学习一些新的语法和概念，对初学者来说可能会有一定的学习曲线。
- 可读性较差：由于JSX嵌入了JavaScript代码，语法相对于模板语法可能会更复杂一些，可读性稍差一些。

在选择使用Vue的模板语法还是React的JSX语法时，需要根据项目需求、团队技术栈以及个人偏好进行权衡。如果你更喜欢HTML类似的模板语法，并且希望快速上手和与非开发人员协作，那么Vue的模板语法可能更适合。如果你更倾向于使用JavaScript编写组件逻辑，并享受更灵活和强大的编程能力，那么React的JSX语法可能更适合。最终选择取决于具体情况和项目需求。


# 获取元素的尺寸和位置为什么会导致页面回流


获取元素的尺寸和位置会导致页面回流的原因是，浏览器在计算元素的尺寸和位置时需要依赖于其他元素的信息，而这些信息可能会受到其他元素的改变影响，从而触发页面重新布局。

当我们通过JavaScript或CSS的属性（如offsetWidth、offsetHeight、clientWidth、clientHeight、getBoundingClientRect()等）来获取元素的尺寸和位置时，浏览器会执行以下步骤：

1. 首先，浏览器会暂停渲染过程，然后遍历DOM树并计算元素的几何属性。
2. 计算完所有相关元素的尺寸和位置后，浏览器会进行布局（也称为回流）以确保所有元素相对于父元素和其他兄弟元素的正确位置。
3. 最后，浏览器完成布局后，将继续渲染页面。

由于页面回流涉及多个元素的重新布局，它的计算量较大，因此频繁地获取元素的尺寸和位置会导致性能问题。如果在短时间内多次调用获取尺寸和位置的方法，浏览器将不得不频繁地进行回流操作，导致页面的响应性能下降。

为了避免这种情况，可以采取以下优化措施：

- 将需要获取元素尺寸和位置的操作批量执行，减少回流次数。
- 在进行元素样式或布局的修改之前，先将元素从DOM树中移除，然后再添加回去，这样可以避免触发多次回流。
- 使用CSS的transform属性来进行位移、缩放等操作，因为transform属性不会触发回流，可以提高性能。

总而言之，避免频繁获取元素的尺寸和位置可以减少页面回流，提高网页的性能和响应速度。

# 为什么transform不会回流

transform属性不会导致回流的原因是，它会在独立的图层上进行操作，并不会影响其他元素的布局。当使用transform属性对元素进行位移、缩放、旋转等变换时，浏览器会通过硬件加速将该元素绘制到一个单独的图层上。

由于这个图层与其他图层相互独立，所以对该图层的变换并不会触发整个页面的重新布局。浏览器可以单独处理该图层的变换，而不需要重新计算其他元素的位置和大小。

因此，使用transform属性来实现动画或交互效果可以提高性能，特别是在需要频繁进行变换的情况下。相比于修改元素的尺寸或位置等属性，transform属性只需进行简单的矩阵运算，对性能的影响较小。

需要注意的是，虽然transform属性本身不会导致回流，但如果同时修改了其他影响布局的属性（如改变元素的宽度、高度等），仍然可能触发回流。因此，在使用transform属性时，最好避免对影响布局的其他属性进行频繁修改，以充分利用transform的优势。