# 环境准备
* 安装node
* 使用nide运行js代码
* 使用code runner 插件
   
# 知识回顾-数据的表达1

* 知识的回顾-数据的表达1
  
    * 注意点
      * 标识符
      * 转义符

和MTML、CSS不同，JS是一门 命令式编程语言，和其它命令式语言一样，它的本质是处理数据

JS提供了三种方式来表达一个数据

* 变量
* 字面量
* 表达式

程序中的任何需要数据的地方，都可以使用上面任意一种数据表达。
## 注意点

### 标识符
程序中有些可以自行命名的地方，称为标识符

>常见的标识符有：变量名、函数名、参数名

js的标识符必须符合以下规则：
* 允许数字、字母、下划线、$符号
* 不得以数字开头
* 不能和关键字冲突
* 建议使用驼峰命名法

一个完整的程序中，会涉及成百上千的标识符，好的名称不仅可以减少命名的冲突，更有利于程序的阅读和维护。

名称要做到 望文知意

### 转义符
---
| 转义符 | 含义           |
| ------ | -------------- |
| \ '    | 普通英文单引号 |
| \ “    | 普通英文双引号 |
| \ r    | 回车           |
| \ n    | 换行           |

>小技巧：常用 \r\n 表示换行

# 知识回顾-数据的表达2

* 知识回顾-数据的表达2
  * 注意点

    * 数据类型
    * 对象的原始写法

## 注意点
### 数据类型
---

原始类型： number、string、null、bollean、 undefined、Symbol、BigInt

引用对象：对象（包含普通对象、数组、函数）

对象的原始写法
---

对象的所有属性名都是字符串，因此使用单引号或双引号包裹起来
> {
> 
> 'name': ‘张三’，
> 
>‘age':18,
>
>'sex':‘男’,
> 
> }

为了书写方便，当对象的属性名是纯数字或者符合标识符规范时，可以省略引号

读取对象的属性时，使用[]，要把读取的属性名传递到括号中，若属性符合标识符规范，可以使用.符号连接属性名（默认转为 [] 语法）---〉语法糖

# 知识回顾-数据的表达3

数组，用于表达多种类的数据，本质也是一个对象

# 知识回顾-数据的运算

* 知识回顾-数据的运算
  * 运算符
  
    * 算数（数学）运算
    * 字符串拼接
    * 赋值运算
    * 比较运算
    * 逻辑运算
  
  * 布尔判定
  * 类型的隐式转换

## 运算符
算数（数字）运算
---
支持：（加）+、（减）-、（乘）*、（除）/、（求余）%

算数运算的表达式一定返回数字，可以利用其特点做类型转换，参考类型的隐式转换


## 字符串的拼接

当 + 的两端有一个是字符串时，不再进行算数运算，而变为字符串拼接

表达式一定返回string，可以利用其特点做类型转换

## 赋值运算

涉及的运算符：=、 += 、*=、/=、%=

其中，a += xxx， 等效于 a = a + （xxx）

## 比较运算符

涉及的运算符： ==、 ===、！=、！==、>、>=、<、<=


## 逻辑运算

逻辑运算会涉及到布尔判定

运算符：！

对后边的数据取反，表达式一定返回boolean。

可以利用其特点做类型转换，参考类型的隐式转换

运算符： &&

并且，真真为真，其它为假，具有短路规则。

表达式 返回 最后一个判定的数据

运算符：||

或者，假假为假，其它为真，具有短路规则

表达式返回 最后一个判定的数据

运算符：？：，格式a？b：c

三目运算符，判定a，为真时表达式返回b，否则返回c

## 布尔判定

所有需要判断真假的地方都会使用下面的规则

| 数据                                        | 判定  |
| ------------------------------------------- | ----- |
| false ｜ null｜ undefined ｜ 0 ｜ NaN ｜ ‘’ | false |
| 剩余数据                                    | true  |


## 类型的隐事转换

每个运算符都有自己期望的数据，比如 * 期望两端 都是数字

一旦数据不符合运算符的期望，js就会悄悄地对数据进行类型的转换，把他转换成期望的值进行运算。

值得注意的是，转种转换 是临时的，并不会对 原数据造成影响

> var n = +a;  会被专成数字
>
> var s = a + ‘’； 会被转成字符串
>
> var b = ！！a； 会被转为boolean

# 知识回顾-流程的切割

## 函数的作用

使用函数切割流程，不仅可以减少重复代码、还可以有效的降低整体的复杂度。

### 函数的常见问题

#### 理解函数的参数、返回值、函数体

* 参数：表示完成流程所需的必要信息
* 返回值：表示完成流程后产生的结果
* 函数体：表示具体的流程

`
函数的参数、返回值只取决于函数的作用，与函数题体无关
`

#### 函数-->程序变得复杂?

* 原则：

  * 定义函数时，只需要考虑这个函数如何实现，不考虑其它无关的东西
  * 调用函数的时候，只需要考虑向其传递什么参数，如何使用它的返回结果，完全无需考虑函数的具体实现。

# 数据的存储和传递

# 作用域

1. js有两种作用域：全局作用域和函数作用域
 * 内部的作用域能访问外部，反正不行。访问时从内向外依次查找。
 * 如果在内部的作用域中访问了外部，则会产生闭包。
 * 内部作用域能访问的外部，取决于函数定于的位置，和调用无关

2. 作用域内定义的变量、函数声明会提升到作用域顶部

# 全局对象

无论是浏览器环境，还是node环境，都会提供一个全局对象

* 浏览器环境： window
* node环境：goloal

全局对象有下面几个特点：

* 全局对象的属性可以直接被访问
* 给未声明的变量赋值，实际就是给全局对象的变量赋值
* 所有的全局对象、全局函数都会附加到全局对象

`
这称之为全局污染，又称之为全局暴露，或简称污染、暴露
如果要避免污染，需要使用 立即执行函数 改变其作用域
立即执行函数又称之为IIFE，全称是Immediately Invoked Function Expression
IIFe通常用于强行改变作用域
`

# 构造函数

在JavaScript中，构造函数是用于创建特定类型对象的函数。它们通常与"new"关键字一起使用来实例化一个对象。

构造函数可以通过使用"this"关键字来定义对象的属性和方法。当使用"new"关键字调用构造函数时，一个新的对象将被创建，并且构造函数内部的代码将被执行。这个新创建的对象将成为构造函数的实例。

构造函数的命名约定通常以大写字母开头，以便与其他函数区分开来。例如：

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;

  this.sayHello = function() {
    console.log("Hello, my name is " + this.name);
  };
}

var person1 = new Person("John", 25);
var person2 = new Person("Alice", 30);

person1.sayHello(); // 输出：Hello, my name is John
person2.sayHello(); // 输出：Hello, my name is Alice
```

在上面的例子中，Person就是一个构造函数。它有两个参数name和age，以及一个sayHello方法。当使用"new"关键字创建一个新的Person对象时，name和age的值将作为参数传递给构造函数，并且会创建一个具有这些属性和方法的新对象。

总结来说，构造函数可以理解为一个用于创建对象的特殊函数，它定义了对象的属性和方法，并且可以通过"new"关键字来实例化对象。

# 原型

在JavaScript中，原型（prototype）是一个对象，它用于实现对象之间的继承关系和共享属性和方法。

每个JavaScript对象都有一个原型，它是一个指向另一个对象的引用。原型形成了对象之间的原型链（prototype chain），并且允许对象继承另一个对象的属性和方法。

当访问一个对象的属性或方法时，如果对象本身没有该属性或方法，JavaScript会沿着原型链向上查找，直到找到该属性或方法或者到达原型链的顶部（即Object.prototype）。这样，对象可以继承原型对象的属性和方法。

原型的概念允许在JavaScript中实现对象的继承和共享属性和方法。通过在原型对象上定义属性和方法，所有由该原型对象创建的实例对象都可以访问和使用这些属性和方法。这样可以避免在每个实例对象上重复定义和占用内存。

总结起来，原型是JavaScript中实现对象继承和共享属性和方法的机制，它允许对象之间通过原型链来共享和继承。


## 原型之间的关系

1. 原型：每个函数都会附带一个属性prototype，这个属性的值是一个普通对象，称之为原型对象
2. 实例：instance，通过new产生的对象称之为 实例

>由于JS中所有的对象都是通过new产生的，因此，严格来说，JS中所有的对象都称之为实例

3. 隐式原型：每个实例都拥有一个特殊的属性--proto--,称之为隐式原型，它指向构造函数的原型


# this相关

不同的场景中，这（this）指代的含义不同，JS中的this关键字也是如此：

* 在全局代码中使用this，指代全局对象

> 在真实的开发中，很少在全局代码使用this

* 在函数中使用this，他的指向完全取决于函数是如何被调用的

| 调用方式       | 示例                | 函数中的this指向 |
| -------------- | ------------------- | ---------------- |
| 通过new调用    | new  method（）     | 新对象           |
| 直接调用       | method（）          | 全局对象         |
| 通过对象掉调用 | obj.method（）      | 前面的对象       |
| call           | method.call（ctx）  | call的第一个参数 |
| apply          | method.apply（ctx） | call的第一个参数 |

改变this 的方法：


在JavaScript中，有多种方式可以改变函数中`this`的指向。以下是几种常见的方式：

1. 使用`call()`方法或`apply()`方法：这两个方法允许你显式地指定函数的上下文（即`this`的值）。`call()`方法接受一个指定的上下文对象作为第一个参数，后面是函数的参数列表。`apply()`方法与`call()`类似，只是它接受一个数组作为函数的参数列表。

2. 使用`bind()`方法：`bind()`方法会创建一个新的函数，并将其上下文（即`this`的值）绑定到指定的对象。返回的函数可以稍后调用。

3. 使用箭头函数：箭头函数不会创建自己的`this`，而是会继承其父函数的`this`。这意味着在箭头函数中，`this`的值是在定义时确定的，而不是在运行时确定的。

4. 通过闭包保存`this`：在函数内部使用闭包可以在函数外部保存`this`的值，并在需要时访问它。

以下是每种方式的示例：

```javascript
// 使用call()
var obj1 = { name: "Alice" };

function sayHello() {
  console.log("Hello, " + this.name + "!");
}

sayHello.call(obj1); // 输出 "Hello, Alice!"

// 使用apply()
var obj2 = { name: "Bob" };
var args = ["Hi"];

function sayGreeting(greeting) {
  console.log(greeting + ", " + this.name + "!");
}

sayGreeting.apply(obj2, args); // 输出 "Hi, Bob!"

// 使用bind()
var obj3 = { name: "Charlie" };

function sayHi() {
  console.log("Hi, " + this.name + "!");
}

var sayHiWithObj3 = sayHi.bind(obj3);
sayHiWithObj3(); // 输出 "Hi, Charlie!"

// 使用箭头函数
var obj4 = { name: "David" };

var sayHola = () => {
  console.log("Hola, " + this.name + "!");
};

sayHola.call(obj4); // 输出 "Hola, David!"

// 闭包保存this
var obj5 = { name: "Eve" };

function sayBonjour() {
  var self = this;
  function innerFunc() {
    console.log("Bonjour, " + self.name + "!");
  }
  innerFunc();
}

sayBonjour.call(obj5); // 输出 "Bonjour, Eve!"
```

请注意，某些情况下，函数的`this`值是由调用方式决定的，无法通过以上方法来更改。例如，在使用事件处理程序时，函数的`this`通常会自动绑定到触发事件的元素。

## 约定

在对象中的方法一般使用this 获取当前对象的方法

# BOM对象


# DOM对象

获取dom方法。。。

修改dom树。。。

### dom属性：
* 标准属性：HTML元素本身拥有的属性
* 自定义属性：HTML元素标准未定义的属性

> 所有的标准属性均可以通过dom.属性名取得

* 布尔属性会被自动转换为boolean
* 路径类的属性被转换为绝对路径
* 标准属性始终都是存在的，不管你是否有在元素中属性改属性

> 所有的自定义属性均可通过下面的方式操作：

* dom.setAttribute(name, value),设置属性键值对
* dom.getAttribute(name),获取属性值

自定义属性和元素源码书写是对应的，可以尝试获取a元素的href属性对比标准属性，看看不同之处

### css样式